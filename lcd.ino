//#include "lcd.h"
#include <Arduino.h>
#include <driverlib/sysctl.h>
#include <inc/hw_gpio.h>
//SSD1298,1289 lib
#define RGB(red, green, blue)	((unsigned int)( (( red >> 3 ) << 11 ) | \
								(( green >> 2 ) << 5  ) | \
								( blue  >> 3 )))
static const byte Verdana_font_11[] = {
    0,   // format
    11,   // fontHeight
    9,   // ascent
    33,   // from
    95,   // count
    59,   // totalWidth/8
    0x00,0x01,0x00,0x04,0x00,0x0B,0x00,0x10,0x00,0x1A,0x00,0x21,0x00,0x22,0x00,0x25,0x00,0x28,0x00,0x2D,0x00,0x34,0x00,0x36,0x00,0x39,0x00,0x3A,0x00,0x3F,0x00,0x44,0x00,0x49,0x00,0x4E,0x00,0x53,0x00,0x59,0x00,0x5E,0x00,0x63,0x00,0x68,0x00,0x6D,0x00,0x72,0x00,0x73,0x00,0x75,0x00,0x7B,0x00,0x82,0x00,0x88,0x00,0x8C,0x00,0x94,0x00,0x9A,0x00,0xA0,0x00,0xA7,0x00,0xAE,0x00,0xB3,0x00,0xB8,0x00,0xBF,0x00,0xC5,0x00,0xC8,0x00,0xCC,0x00,0xD2,0x00,0xD7,0x00,0xDE,0x00,0xE4,0x00,0xEB,0x00,0xF0,0x00,0xF7,0x00,0xFD,0x01,0x03,0x01,0x0A,0x01,0x10,0x01,0x16,0x01,0x1F,0x01,0x25,0x01,0x2C,0x01,0x32,0x01,0x35,0x01,0x3A,0x01,0x3D,0x01,0x44,0x01,0x4B,0x01,0x4D,0x01,0x52,0x01,0x57,0x01,0x5C,0x01,0x61,0x01,0x66,0x01,0x6A,0x01,0x6F,0x01,0x74,0x01,0x75,0x01,0x78,0x01,0x7D,0x01,0x7E,0x01,0x87,0x01,0x8C,0x01,0x91,0x01,0x96,0x01,0x9B,0x01,0x9F,0x01,0xA3,0x01,0xA7,0x01,0xAC,0x01,0xB1,0x01,0xB8,0x01,0xBD,0x01,0xC2,0x01,0xC6,0x01,0xCB,0x01,0xCC,0x01,0xD1,0x01,0xD8,0x01,0xD8,    // Col ends
    0x50,0x04,0x00,0x00,0x4C,0x20,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x38,0x00,0x10,0x20,0x00,0x80,0xC1,0x09,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,    // Line 0
    0xD1,0x44,0x62,0x18,0x52,0xA8,0x00,0x02,0xE2,0x39,0xC1,0x7C,0xDF,0x73,0x80,0x00,0x00,0xE3,0xE3,0x3C,0x3D,0xF3,0xFF,0x3D,0x0F,0x78,0x61,0x8F,0x13,0x9E,0x39,0xE3,0xDF,0xE1,0x86,0x23,0x0C,0x1F,0xE4,0x08,0x80,0x08,0x20,0x00,0x81,0x01,0x00,0x84,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x92,0x00,    // Line 1
    0xD1,0x4F,0x92,0x24,0x52,0x70,0x80,0x05,0x1E,0x46,0x23,0x41,0x01,0x8C,0x40,0x00,0x00,0x14,0x13,0x22,0x43,0x0A,0x10,0x43,0x0A,0x18,0xA1,0x8F,0x14,0x51,0x45,0x14,0x22,0x21,0x86,0x23,0x0A,0x20,0x62,0x09,0x40,0x00,0x20,0x00,0x81,0x01,0x00,0x84,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x92,0x00,    // Line 2
    0x87,0xF4,0x94,0x24,0x21,0xA8,0x80,0x05,0x12,0x04,0x25,0x42,0x02,0x8C,0x68,0x60,0x30,0x19,0xD4,0xA2,0x81,0x06,0x10,0x81,0x0A,0x19,0x21,0x56,0x98,0x31,0x83,0x14,0x02,0x21,0x85,0x54,0x91,0x40,0xA2,0x0A,0x20,0x03,0xBC,0xE7,0xBB,0xDF,0xEB,0x8F,0xDD,0xE7,0x79,0xF6,0xFF,0x18,0xC9,0x8C,0x7C,0x92,0x00,    // Line 3
    0x82,0x94,0x64,0x19,0x21,0x20,0x80,0x09,0x12,0x08,0xC9,0x7B,0xC2,0x74,0x69,0x9F,0xCC,0x2A,0x54,0xBE,0x81,0x07,0xFE,0x81,0xFA,0x1A,0x21,0x56,0x98,0x31,0x83,0x13,0x02,0x21,0x49,0x54,0x60,0x81,0x21,0x0C,0x10,0x00,0x63,0x18,0xC5,0x23,0x19,0x96,0x23,0x18,0xC6,0x39,0x09,0x18,0xC9,0x52,0x84,0x92,0x31,    // Line 4
    0x82,0x8E,0x09,0xA5,0x21,0x07,0xF3,0x89,0x12,0x10,0x31,0x06,0x24,0x8B,0xC6,0x00,0x03,0x4A,0x54,0xA1,0x81,0x06,0x10,0x8F,0x0A,0x1E,0x21,0x26,0x58,0x3E,0x83,0xE0,0xC2,0x21,0x49,0x54,0x60,0x82,0x21,0x08,0x00,0x03,0xE3,0x08,0xFD,0x23,0x19,0xA6,0x23,0x18,0xC6,0x31,0x89,0x15,0x55,0x22,0x8B,0x11,0xC9,    // Line 5
    0x8F,0xC5,0x0A,0x62,0x21,0x00,0x80,0x11,0x12,0x20,0x3F,0x86,0x24,0x88,0x41,0x9F,0xCC,0x4A,0x5F,0xE1,0x81,0x06,0x10,0x83,0x0A,0x19,0x21,0x26,0x58,0x30,0x83,0x20,0x22,0x21,0x49,0x54,0x90,0x84,0x20,0x88,0x00,0x04,0x63,0x08,0xC1,0x23,0x19,0xE6,0x23,0x18,0xC6,0x30,0x69,0x15,0x55,0x22,0x90,0x92,0x46,    // Line 6
    0x05,0x05,0x12,0x63,0x21,0x00,0x84,0x51,0x12,0x42,0x21,0x46,0x28,0x88,0xA8,0x60,0x30,0x09,0xA8,0x61,0x43,0x0A,0x10,0x43,0x0A,0x18,0xA1,0x06,0x34,0x50,0x45,0x14,0x22,0x21,0x30,0x89,0x08,0x88,0x20,0x88,0x00,0x04,0x63,0x18,0xC5,0x23,0x19,0x96,0x23,0x18,0xC6,0x30,0x29,0x12,0x22,0x51,0x20,0x92,0x00,    // Line 7
    0x85,0x1E,0x11,0x9C,0x92,0x00,0x84,0x60,0xEF,0xFD,0xC1,0x39,0xC8,0x73,0x28,0x00,0x00,0x44,0x08,0x7E,0x3D,0xF3,0xF0,0x3D,0x0F,0xE8,0x7F,0x06,0x33,0x90,0x39,0x0B,0xC2,0x1E,0x30,0x89,0x08,0x8F,0xE0,0x48,0x00,0x03,0xFC,0xE7,0xB9,0x1F,0x19,0x8E,0x23,0x17,0x79,0xF1,0xC6,0xF2,0x22,0x89,0x3C,0x92,0x00,    // Line 8
    0x00,0x04,0x00,0x00,0x12,0x00,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x48,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x40,0x20,0x00,0x00,0x00,0x01,0x00,0x92,0x00,    // Line 9
    0x00,0x04,0x00,0x00,0x0C,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x0F,0xE0,0x00,0x00,0x00,0x1C,0x06,0x00,0x00,0x00,0x40,0x20,0x00,0x00,0x00,0x02,0x00,0x7C,0x00,    // Line 10
};

void inline LCD_WriteIndex(byte index)
{
  LCD_RS_LO;

  LCD_LOFF;
  LCD_BUS = index;
  LCD_LON;
  LCD_BUS = 0x00;
  
  LCD_WR_LO;
//  asm("nop");
  LCD_WR_HI;
  
  LCD_RS_HI;
}

inline void LCD_WriteData(unsigned short int data)
{
  
  LCD_LOFF;
  LCD_BUS = data&0xFF;
  LCD_LON;
  LCD_BUS = data>>8;

  LCD_WR_LO;
  asm("nop");
  LCD_WR_HI;

}

inline void LCD_WriteData(unsigned int data)
{
  
  LCD_LOFF;
  LCD_BUS = data&0xFF;
  LCD_LON;
  LCD_BUS = data>>8;

  LCD_WR_LO;
  asm("nop");
  LCD_WR_HI;

}

void LCD_WriteReg(byte index, unsigned short int data)
{
  // Write Index
  LCD_WriteIndex(index);
  // Write Data
  LCD_WriteData(data);
}  

void LCD_Init()
{
  pinMode(LCD_RESET, OUTPUT); // Set reset pin As Output
  LCD_RESET_LO;               // Hold in reset
  pinMode(LCD_RS, OUTPUT);    // Set RS pin As Output
  LCD_RS_LO;  
  pinMode(LCD_WR, OUTPUT);    // Set WR pin As Output
  pinMode(LCD_LE, OUTPUT);
  LCD_WR_HI;  
  
  ROM_GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, 0xFF); // Set Data BUS As Output
 
  // Reset controller
  LCD_RESET_LO;
  delay(2);
  LCD_RESET_HI;
  delay(2);
  
  LCD_WriteReg(0x0000,0x0001);  //Start oscillator
  delay(15);
  LCD_WriteReg(0x0003,0xAAAC); //Power Control
  LCD_WriteReg(0x000C,0x0002);
  LCD_WriteReg(0x000D,0x000A);
  LCD_WriteReg(0x000E,0x2C00);
  LCD_WriteReg(0x001E,0x00B8);
  delay(15);
//  LCD_WriteReg(0x0001,0x2B3F); //?
  LCD_WriteReg(0x0002,0x1000); //1
  // Restore VSYNC mode from low power state
  LCD_WriteReg(0x0010,0x0000); //Sleep mode disable
  LCD_WriteReg(0x0011,0x6030); //Entry Mode - auto increment address
  delay(30);
  LCD_WriteReg(0x0005,0x0000); // Compare register
  LCD_WriteReg(0x0006,0x0000); // Compare register
  // Horizontal and Vertical porch are for DOTCLK mode operation
  LCD_WriteReg(0x0016,0xEF1C); // Horizontal Porch 
  LCD_WriteReg(0x0017,0x0003); // Vertical Porch
  // Display Control
  LCD_WriteReg(0x0007,0x0233); // Display Control
  LCD_WriteReg(0x000B,0x5308);//5312); // Frame cycle control
  LCD_WriteReg(0x000F,0x0000); // Gate Scan Position 
  delay(20);
  // Vertical Scroll Control
  LCD_WriteReg(0x0041,0x0000); // Vertical Scroll Control
  LCD_WriteReg(0x0042,0x0000); // Vertical Scroll Control
  // 1st Screen driving position
  LCD_WriteReg(0x0048,0x0000); // Start position. 0
  LCD_WriteReg(0x0049,0x013F); // End position.   319
  // Source RAM address
  LCD_WriteReg(0x0044,0xEF00); //Horizontal RAM address position start/end setup 
  LCD_WriteReg(0x0045,0x0000); //Vertical RAM address start position setting 
  LCD_WriteReg(0x0046,0x013F); //Vertical RAM address end position setting (0x013F = dec 319)

  delay(20); 
  //gamma control 
  LCD_WriteReg(0x0030,0x0707);
  LCD_WriteReg(0x0031,0x0704);
  LCD_WriteReg(0x0032,0x0204);
  LCD_WriteReg(0x0033,0x0201);
  LCD_WriteReg(0x0034,0x0203);
  LCD_WriteReg(0x0035,0x0204);
  LCD_WriteReg(0x0036,0x0204);
  LCD_WriteReg(0x0037,0x0502);
  LCD_WriteReg(0x003A,0x0302);
  LCD_WriteReg(0x003B,0x0500);
  delay(20);
}

void LCD_ModeRD()
{
  LCD_WriteReg(0x0011,0b110000000110000);
}

void LCD_ModeRU()
{
  LCD_WriteReg(0x0011,0b110000000010000);
}

void LCD_ModeLU()
{
  LCD_WriteReg(0x0011,0b110000000000000);
}

void LCD_ModeDL()
{
  LCD_WriteReg(0x0011,0b110000000101000);
}

void LCD_ModeDR()
{
  LCD_WriteReg(0x0011,0b110000000111000);
}

void LCD_SetCursor(unsigned char x, unsigned short int y)
{
if (x < 240 && y < 320) {
    LCD_WriteReg(0x4E, x);
    LCD_WriteReg(0x4F, y);
}  
}

void LCD_SetWindow(byte x1, unsigned short int y1, byte x2, unsigned short int y2)
{
  LCD_WriteReg(0x44,(x2 << 8) | x1);    // Source RAM address window 
  LCD_WriteReg(0x45,y1);    // Gate RAM address window 
  LCD_WriteReg(0x46,y2);            
  //delay(1);
  LCD_SetCursor(x1, y1);  
}



void LCD_SolidFill(unsigned int count, unsigned short int color)
{
  // Write Index
  LCD_WriteIndex(0x22);

//  LCD_RS_HI;
  LCD_LOFF;
  LCD_BUS = color&0xFF;
  LCD_LON;
  LCD_BUS = color>>8;
  while(count){
  LCD_WR_LO;
    asm("nop"); //This really helps if you use -O2 gcc option like me. With default -Os this could be removed.
  LCD_WR_HI;
  count--;
  }
}

void LCD_Clear(unsigned short int color)
{
  LCD_SetCursor(0,0);
  /*LCD_WriteIndex(0x22);
  for (long i=0; i <= 76799; i++){
    LCD_WriteData(color);
  }
  */
  LCD_SolidFill(76800, color);  // This is a faster method
}

void LCD_PutPixel(byte x, unsigned short int y, unsigned short int color)
{
  LCD_SetCursor(x,y);
  LCD_WriteIndex(0x22);
  LCD_WriteData(color);
}  

void LCD_HorLine(byte x1, byte x2, unsigned short int y, unsigned short int color)
{
if (x1 < 240 && x2 < 240 && y < 320) {
  LCD_SetCursor(x1,y);
  /*LCD_WriteIndex(0x22);
  for (byte i=x1; i < x2; i++){
    LCD_WriteData(color);
  }
  */
  LCD_SolidFill((x2-x1+1), color);  // This is a faster method
}  
}  

void LCD_VerLine(unsigned short int y1, unsigned short int y2, byte x, unsigned short int color)
{
  LCD_SetWindow(x,y1,x,y2);
  LCD_WriteIndex(0x22);
  for (unsigned short int i=y1; i <= y2; i++){
    LCD_WriteData(color);
  }
  
//  LCD_SolidFill((y2-y1), color);  // This is a faster method
  LCD_ResetWindow();
}  

void LCD_HardwareScroll(short int y)
{
    while (y < 0)
        y += 320;
    while (y >= 320)
        y -= 320;
    LCD_WriteReg(0x41,y);
}    

void LCD_Clear_ScrollUp(byte delay_between, unsigned short int color)
{
  for (int i=1; i <= 320; i++) {    
    LCD_HardwareScroll(i);
    LCD_HorLine(0,239,i-1,color);    
    delay(delay_between);
  }
  LCD_HardwareScroll(0);
}  

void LCD_Clear_ScrollDown(byte delay_between, unsigned short int color)
{
  for (int i=-1; i >= -320; i--) {    
    LCD_HorLine(0,239,320+i,color);  
    LCD_HardwareScroll(i);  
    delay(delay_between);    
  }
  LCD_HardwareScroll(0);  
} 

int LCD_DrawChar(byte xx, unsigned short int yy, int c, unsigned short int color)
{
    //byte* f = Verdana_font_11;
    if (c == 32)
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);

    int i = c - FNT(3);
    if (i < 0 || i >= FNT(4)) return 0;

    int ci = 6 + i * 2;
    int width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
    int height = FNT(1);
    int src = 0;
    if (i > 0)
    {
        src = (FNT(ci - 2) << 8) | FNT(ci - 1);
        width -= src;
    }
    
    //  clip?
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
        {
            if (p & m)
                LCD_PutPixel(x + xx, y + yy, color);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
            }
        }
        src += makeup;
    }
    return width;
}

void LCD_DrawString2(const char* s, int len, byte x, unsigned short int y, unsigned short int color)
{
    for (int i = 0; i < len; i++)
        x += LCD_DrawChar(x,y,s[i], color) + 1;
}

void LCD_DrawString(const char* s, byte x, unsigned short int y, unsigned short int color)
{
    LCD_DrawString2(s,strlen(s),x,y, color);
}

void LCD_Rectangle(byte x1, unsigned short int y1, byte x2, unsigned short int y2, unsigned short int color)
{      
    LCD_SetWindow(x1,y1,x2,y2);
//    LCD_SetCursor(x1,y1);
    
    byte width = x2-x1+1;
    unsigned short int height = y2-y1+1;
    LCD_SolidFill(width*height, color);
    LCD_ResetWindow();
    
	/*register*/ /*unsigned int x,y;

	LCD_SetWindow(x1, y1, x2, y2);
LCD_WriteIndex(0x22);
    for(y=y1; y<=y2; y++)
	{
        for(x=x1; x<=x2; x++)
		{
			LCD_WriteData(color);
        }
    }
	LCD_SetWindow(0, 0, 239, 319);*/
}
